# src/db/functions.py

from asyncpg import Connection
from typing import Any, Dict
import json

async def call_webhook_function(conn: Connection, payload: Dict[str, Any]) -> Any:
    # –ü—Ä–∏–º–µ—Ä: –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ —Å—Ö–µ–º–µ to_can
    json_str = json.dumps(payload, ensure_ascii=False)
    result = await conn.fetchval(
        "SELECT to_can.f_syspay($1::json)",
        json_str
    )
    return result

# src/db/pool.py

from asyncpg import Pool, create_pool

from src.settings import settings

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø—É–ª—ã (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ: analytics_pool, auth_pool –∏ —Ç.–¥.)
_main_db_pool: Pool | None = None

async def init_pools():
    global _main_db_pool, _accounts_db_pool
    if _main_db_pool is None:
        # üëá –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º PostgresDsn ‚Üí str
        _main_db_pool = await create_pool(dsn=str(settings.database_url))

async def close_pools():
    global _main_db_pool, _accounts_db_pool
    if _main_db_pool:
        await _main_db_pool.close()
        _main_db_pool = None

def get_main_db_pool() -> Pool:
    if _main_db_pool is None:
        raise RuntimeError("Main DB pool not initialized")
    return _main_db_pool

# src/dependencies/db.py

from asyncpg import Pool

from src.db.pools import get_main_db_pool

# –≠—Ç–æ ‚Äî "—Ç–æ—á–∫–∞ –∏–Ω—ä–µ–∫—Ü–∏–∏" –¥–ª—è FastAPI
def get_db_pool() -> Pool:
    """–î–ª—è –≤–µ–±—Ö—É–∫–æ–≤ ‚Üí paydb"""
    return get_main_db_pool()

# src/dependencies/webhook.py

from fastapi import Depends
from asyncpg import Pool, PostgresError
from loguru import logger

from src.schemas.webhook import WebhookPayload
from src.db.functions import call_webhook_function
from src.exceptions.exceptions import DatabaseError, WebhookProcessingError
from src.dependencies.db import get_db_pool

async def process_webhook_payload(
    payload: WebhookPayload,
    db_pool: Pool = Depends(get_db_pool)
):
    try:
        async with db_pool.acquire() as conn:
            result = await call_webhook_function(conn, payload.model_dump())
        return result
    except PostgresError as e:
        logger.error(f"PostgreSQL error: {e}")
        raise DatabaseError(detail="Database error")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise WebhookProcessingError(detail="Internal processing error")

# src/exceptions/exceptions.py

from fastapi import HTTPException

class WebhookProcessingError(HTTPException):
    def __init__(self, detail: str = "Failed to process webhook"):
        super().__init__(status_code=500, detail=detail)

class InvalidWebhookData(HTTPException):
    def __init__(self, detail: str = "Invalid webhook data"):
        super().__init__(status_code=400, detail=detail)

class DatabaseError(HTTPException):
    def __init__(self, detail: str = "Database unavailable"):
        super().__init__(status_code=503, detail=detail)

# src/routers/webhook.py

from fastapi import APIRouter, Depends

from src.dependencies.webhook import process_webhook_payload

router = APIRouter(tags=["Webhooks"])

@router.post("",
             summary="Process incoming webhook from payment system",
             description="Validates and stores webhook payload from payment gateway into legacy database (`paydb`).",
             operation_id="process_payment_webhook",
             )
async def get_hook(result = Depends(process_webhook_payload)):
    return result

# src/schemas/webhook.py

from pydantic import BaseModel, ConfigDict

class WebhookPayload(BaseModel):
    model_config = ConfigDict(extra="allow")  # —Ä–∞–∑—Ä–µ—à–∏—Ç—å –ª—é–±—ã–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è

    Id: str
    MID: str
    Amount: str
    ReaderId: str
    CreatedAt: str
    Inputtype: int
    ClientName: str
    Description: str

# src/services/db_service.py

from asyncpg import Connection
from loguru import logger

from src.exceptions.exceptions import InvalidWebhookData

async def call_webhook_function(conn: Connection, payload: dict) -> dict:
    try:
        logger.debug(f"Calling DB function with keys: {list(payload.keys())}")
        result = await conn.fetchval("SELECT to_can.process_webhook($1)", payload)

        if isinstance(result, dict) and result.get("error"):
            logger.warning(f"DB rejected webhook: {result['error']}")
            raise InvalidWebhookData(detail=result["error"])

        logger.info("Webhook processed successfully")
        return result

    except Exception:
        logger.exception("Exception in DB function call")
        raise

# src/logger_config.py

from loguru import logger
import os

from src.settings import settings

def setup_logger():
    log_dir = settings.log_dir
    os.makedirs(log_dir, exist_ok=True)
    logger.remove()

    # –õ–æ–≥ –≤ —Ñ–∞–π–ª (–µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è, 6 –º–µ—Å—è—Ü–µ–≤, –∞—Ä—Ö–∏–≤–∞—Ü–∏—è)
    logger.add(
        log_dir / "webhook.log",
        rotation="00:00",
        retention="180 days",
        compression="zip",
        level="INFO",
        encoding="utf-8",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}"
    )

    # –û—à–∏–±–∫–∏ –≤ stderr (–¥–ª—è Docker-–ª–æ–≥–æ–≤)
    logger.add(
        sink=lambda msg: print(msg, end=""),
        level="ERROR"
    )

    return logger

# src/main.py

from contextlib import asynccontextmanager
from fastapi import FastAPI

from src.db.pools import init_pools, close_pools
from src.routers import webhook


@asynccontextmanager
async def lifespan(app):
    await init_pools()
    yield
    await close_pools()


app = FastAPI(lifespan=lifespan)
app.include_router(webhook.router, prefix="/webhook")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("src.main:app", host="0.0.0.0", port=8000, reload=True)

# src/settings.py

from pydantic_settings import BaseSettings
from pydantic import ConfigDict, PostgresDsn
from pathlib import Path


class Settings(BaseSettings):
    database_url: PostgresDsn
    rabbitmq_url: str
    log_dir: Path = Path("./logs")

    model_config = ConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",  # —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å –∫–æ–¥–∏—Ä–æ–≤–∫—É
        extra="forbid",  # –∏–ª–∏ "ignore", –Ω–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî "ignore"
    )


settings = Settings()
